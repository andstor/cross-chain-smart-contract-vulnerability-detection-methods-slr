\chapter{Results}
\label{chap:results}

The results chapter should simply present the results of applying the methods presented in the method chapter without further ado. This chapter will typically contain many graphs, tables, etc. Sometimes it is natural to discuss the results as they are presented, combining them into a ‘Results and Discussion’ chapter, but more often they are kept separate.

\section{Research Question 1: What are the current approaches for \acrlong{sc} vulnerability detection?}


\section{Research Question 2: What are the current defenses against \acrlong{sc} vulnerabilities?}

Not so many tools for actually fixing the vulnerabilities. Maybe some ML techniques?
There are however many tools and techniques for avoiding to introduce vulnerabilities.

Language-Based Security
Manual Inspection and correction

\section{Research Question 3: What is the current research on cross-chain \acrlong{sc} vulnerability detection?}

\textcite{kalra2018zeus} provides a tool called Zeus. Zeus translates the \Gls{solidity} \acrshort{sc} language into LLVM-IR language. \gls{llvm} is a compiler toolchain, that supports a large ecosystem of code analysis tools. However, the \gls{llvmir} is very  is an \acrshort{ir} that  that can be used to detect vulnerabilities in the \acrshortpl{sc} language.


\textcite{lewispye2021general} conducts a systematic literature mapping identifying A General Framework for the Security Analysis of Blockchain Protocols

\section{Research Question 4: How to make \acrlong{sc} vulnerability detecting possible cross-chain?}


\textcite{matsumura2021vulnerabilities} suggest \acrshortpl{ml} for automatic vulnerability detection as future work. This because it is a promising vulnerability detection technique for traditional software, it doesn’t rely heavy on human-defined rules and has obtained competitive results.

for \acrshortpl{sc} vulnerability detection. This because \acrshortpl{ml} has been shown to be a promising vulnerability detection technique 

since it is a promising vulnerability detection technique even for traditional software [7,15], does not rely heavily on rules defined by human experts and has obtained competitive results; research proposing solutions involving dynamic analysis or software testing, seeking to deal with the limitations of the execution environment.
\chapter{Research results}
\label{chap:results}

The results chapter should simply present the results of applying the methods presented in the method chapter without further ado. This chapter will typically contain many graphs, tables, etc. Sometimes it is natural to discuss the results as they are presented, combining them into a ‘Results and Discussion’ chapter, but more often they are kept separate.

There are many existing methods and tools for vulnerability detection. These can be divided up into three categories: Static Vulnerability Detection, Dynamic Vulnerability Detection, and Machine Learning based Vulnerability Detection. The following table lists the tools and their respective categories.

\begin{table}[htp]
    \centering
    \caption{Vulnerabilities enumeration.}
    \label{tab:vulnerabilities-enumeration}
    \begin{tabular}{cllc}
        \toprule
        \# & \textbf{Vulnerability name} & \# & \textbf{Vulnerability name} \\
        \midrule
        1 & Integer Overflow & 4 & Stack Size Limit (deprecated) \\ 
        2 & Integer Underflow & 5 & Timestamp Dependency \\ 
        3 & Transaction-Ordering Dependence & 6 & Reentrancy \\
        
        \bottomrule
    \end{tabular}
\end{table}


\begin{table}[htp]
    \newcolumntype{Y}{>{\centering\arraybackslash}X}
    %\def\arraystretch{1.5}
    \centering
    \caption{Comparison of vulnerability types detectable by existing tools.}
    \label{tab:supported-vulnerabilities}
    \begin{threeparttable}
        \begin{tabularx}{\textwidth}{c*{6}{|Y}}
            \toprule
            \multirow{2}{*}{\textbf{Tool}} & \multicolumn{6}{c}{\textbf{Vulnerability}} \\ \cline{2-7}
            % Integer Overflow, Integer Underflow, TOD, Stack Size Limit, Timesamp Dependency, Reentrancy
            & 1 & 2 & 3 & 4 & 5 & 6 \\
            \hline
            \hline
            ContractWard & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} \\
            ESCORT & & & & & & \\
            Zeus & \ding{51} & \ding{51} & \ding{51} &  & \ding{51} & \ding{51} \\
            Oyente & \ding{51} & \ding{51} &  & \ding{51} & \ding{51} & \ding{51} \\
            Maian\tnote{1} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} \\
            Manticore\tnote{2} & - & - & - & - & - & - \\
            Mythril & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} \\
            Dedaub & ? & ? & ? & ? & ? & \ding{51} \\
            Securify & \ding{55} & \ding{55} & \ding{51} & \ding{55} & ? & \ding{51} \\
            Vandal & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{51} \\
            Towards Sequential\tnote{3} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} \\
            NLP-inspried\tnote{4} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} \\
            Color-inspriedtnote{5} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} \\
            Graph NN-based & \ding{55} & \ding{55} & \ding{55} & \ding{51}\tnote{6} & \ding{51} & \ding{51} \\
            \bottomrule
        \end{tabularx}
        \begin{tablenotes}
            \item[1] Detects Greedy, suicidal and prodigal contracts.
            \item[2] Focuses on maximizing code coverage. Can be somewhat extended to detect more bugs/vulnerabilities.
            \item[3] Based on Maian.
            \item[4] Categories are Suicidal, Prodigal, Greedy, Normal Smart Contracts, and "Prodigal and Greedy".
            \item[5] Authors don't specifically list the detectable vulnerabilities.
            \item[6] Expressed as infinite loop vulnerabilities. This is also problematic for \gls{gas} consumption.
        \end{tablenotes}
    \end{threeparttable}
\end{table}


\section{Research Question 1: What are the current approaches for \acrlong{sc} vulnerability detection?}
\todo{Majority of the tables, and existing vulnerability tools needs to be describeed here.}


\subsection{Static Vulnerability Detection Methods}
"Static detection techniques analyze the smart contract in a static environment by examining its source code or bytecode."


\begin{table}[htp]
    \newcolumntype{Y}{>{\centering\arraybackslash}X}
    %\def\arraystretch{1.5}
    \small
    \centering
    \caption{Existing static smart contract vulnerability detection tools.}
    \label{tab:static-tools}
    \begin{tabularx}{\textwidth}{c|*{4}{Y}}
        \toprule
        \textbf{Name} & \textbf{Method} & \textbf{Capability} & \textbf{Required input}\\ 
        \midrule
        \midrule
        Zeus \cite{kalra2018zeus} &  &  &\\ \hline
        Oyente & Symbolic execution & Multi-class & Source code and bytecode\\ \hline
        Maian & Symbolic analysis & Multi-class & Source code and bytecode\\ \hline
        Manticore \cite{mark2019manticore} & Symbolic execution & Code coverage & Bytecode\\ \hline
        Mythril & Symbolic execution, taint analysis, and SMT & Multi-class & Bytecode\\ \hline
        Securify \cite{tsankov2018securify} & Symbolic analysis & Binary decision & Bytecode\\ \hline
        Vandal \cite{brent2018vandal} & Logic-driven static program analysis & Multi-class & Bytecode\\ \hline
        \bottomrule
    \end{tabularx}
\end{table}

\subsubsection{Information Flow Analysis-based Vulnerability Detection}

\subsubsection{Symbolic Execution-based}
Oyente is a symbolic execution tool for smart contract analysis. 
manticore, Securify, teEther

\subsubsection{Information Flow Analysis-based}
Slither (taint analysis), Dedaubb


\subsection{Dynamic Vulnerability Detection Methods}
"Dynamic testing techniques execute the program and observe its behaviors to determine the vulnerability’s existence."

\begin{table}[htp]
    \newcolumntype{Y}{>{\centering\arraybackslash}X}
    %\def\arraystretch{1.5}
    \small
    \centering
    \caption{Existing dynamic smart contract vulnerability detection tools.}
    \label{tab:dynamic-tools}
    \begin{tabularx}{\textwidth}{c|*{4}{Y}}
        \toprule
        \textbf{Name} & \textbf{Method} & \textbf{Capability} & \textbf{Required input}\\ 
        \midrule
        \midrule
        Dedaub & Flow and loop analysis & Gas-focused vulnerability & Sources code\\ \hline
        \bottomrule
    \end{tabularx}
\end{table}

\subsubsection{Fuzzing-based}
MythX
ReGuard (Reentrancy)
ContractFuzzer (ABI specifications)
Echidna
ILF

\subsubsection{Validation-based}
ContractLarva (runtime verification)
Maian ( "combines symbolic analysis and concrete validation to inspect the smart contract’s bytecode. In concrete validation, the contract is executed on a fork of Ethereum for tracing and vali- dation.")
Sereum 


\subsection{Machine Learning for Vulnerability Detection}
"Several works have attempted to perform automated contract scan- ning using machine learning techniques. We discuss their working mechanisms and limitations below."

\begin{table}[htp]
    \newcolumntype{Y}{>{\centering\arraybackslash}X}
    %\def\arraystretch{1.5}
    \small
    \centering
    \caption{Existing ML-based smart contract vulnerability detection tools.}
    \label{tab:ml-tools}
    \begin{tabularx}{\textwidth}{c|*{4}{Y}}
        \toprule
        \textbf{Name} & \textbf{Method} & \textbf{Capability} & \textbf{Required input}\\ 
        \midrule
        \midrule
        ContractWard & ML (bigram model) & Binary decision & Opcode\\ \hline
        ESCORT & ML (LSTM) + transfer learning & Multi-label & Bytecode\\ \hline
        Towards Sequential & ML (LSTM) & Binary decision & Opcode\\ \hline
        NLP-inspried \cite{gogineni2020multiclass} & ML (AWD-LSTM) & Multi-class & Opcode\\ \hline
        Color-inspried \cite{huang2018hunting} & ML (CNN) & Multi-label & Bytecode\\ \hline
        Graph NN-based \cite{zhuang2020smart} & ML (GNN) & Multi-class & Source code\\
        \bottomrule
    \end{tabularx}
\end{table}

\subsubsection{Long Short-Term Memory}

\subsubsection{Average Stochastic Gradient Descent Weighted Dropped LSTM}

\subsubsection{Convolutional Neural Network}

\subsubsection{Graph Neural Network}

\subsubsection{AWD-LSTM based}

\todo{Determine categoory of ML-based tools.}
\todo{Use multi class or binary decision categories?}
\todo{Use the input as sections?, Eg. AST, bytecode, source code, llvm, etc.}


\subsubsection{ContractWard}
ContractWard \cite{wang2021contractward} implements a smart contract vulnerability detection tool based on machine learning. It is a state-of-the-art tool for detecting smart contract vulnerabilities. It is a multi-label classifier that can detect multiple vulnerabilities. The method is based on a bigram model. The input is the bytecode of the smart contract. The output is a binary decision. The decision is 1 if the contract is vulnerable, 0 otherwise.

Models for Ethereum Smart Contracts Uses XGBoost as multi label classifier with SMOTETomke as sampling method. ses simplified smar contract opcodes as input. the static opcodes represent static featturesof contracts. the tool is appropriate for rapid batch detection of vulnerabilities in smart contracts, with an average detection speed of 4 seconds per contract. Reliable with Micro-F1 and Macro-F1 over 96\%. Only operates on opcodes as input.
simplified smart contract opcodes are extracted from the bytecode of smart contracts.

\subsubsection{ESCORT}
ESCORT provides a long short-term memory machine learning model in order to detect smart contract vulnerabilities. ContractScraper is used to extract the bytecode of the smart contract. The model is based on a long short-term memory (LSTM) network. The model is trained on the Ethereum blockchain. The model is able to detect multiple vulnerabilities. The model is capable of detecting the following vulnerabilities:

"ESCORT, the first Deep Neural Network (DNN)-based vulnerability detection framework for Ethereum smart contracts that supports lightweight transfer learning on unseen security vulnerabilities, thus is exten- sible and generalizable"












\section{Research Question 2: What is the current research on cross-chain \acrlong{sc} vulnerability detection?}

"Cross-chain vulnerability detection is a method for detecting vulnerabilities in smart contract code across multiple blockchains. Little efforts have been made to develop a cross-chain vulnerability detection framework. We discuss the challenges and opportunities of cross-chain vulnerability detection."


\textcite{kalra2018zeus} provides a tool called Zeus. Zeus translates the \Gls{solidity} \acrshort{sc} language into LLVM-IR language. \gls{llvm} is a compiler toolchain, that supports a large ecosystem of code analysis tools. However, the \gls{llvmir} is very is an \acrshort{ir} that  that can be used to detect vulnerabilities in the \acrshortpl{sc} language.

\textcite{lewispye2021general} conducts a systematic literature mapping identifying A General Framework for the Security Analysis of Blockchain Protocols

Besides the articles listed above, to my greatest extent, i have not been able to find any other research directly targeting cross-chain \acrlong{sc} vulnerability detection. However, there are some interesting solutions that demonstrates some cross-chain support.

\todo{Zeus: Emphasize on the need for policies and that it is a prototype implementation.} The most promising tool is Zeus by \textcite{kalra2018zeus} that allows for cross-chain compatibility through the use of \gls{llvm}. By using \gls{llvm}, any \acrshort{sc} language can be translated into the \gls{llvm} language. This is also the only existing tool that also demonstrates cross-chain support through a prototypal mock implementation for Hyperledger Fabric \cite{hyperledger-fabric}. 

Another solution is the \acrshort{sc} language \textsc{Scilla} by \textcite{sergey2018scilla}. This is supposed to be an type of intermediate language based on communicating automata. However, there are no automatic translation tools for converting another language into \textsc{Scilla}. Other similar solutions include converting \gls{solidity} into \gls{f-star}; a general-purpose functional programming language with effects aimed at program verification \cite{f-star}.

\section{Research Question 3: How to make \acrlong{sc} vulnerability detecting possible cross-chain?}

Draft:
Begin with using ML.. Then discuss existing solutions for AST analysis cross languages. 
Present research about cross language analysis. AST solutions, simplifications etc.

\textcite{matsumura2021vulnerabilities} suggest \acrshortpl{ml} for automatic vulnerability detection as future work. This because it is a promising vulnerability detection technique for traditional software, it doesn’t rely heavy on human-defined rules and has obtained competitive results.

for \acrshortpl{sc} vulnerability detection. This because \acrshortpl{ml} has been shown to be a promising vulnerability detection technique 

since it is a promising vulnerability detection technique even for traditional software [7,15], does not rely heavily on rules defined by human experts and has obtained competitive results; research proposing solutions involving dynamic analysis or software testing, seeking to deal with the limitations of the execution environment.